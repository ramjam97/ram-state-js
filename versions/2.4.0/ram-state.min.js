/*!
 * RamStateJs v2.4.0
 * Description: RamStateJs is a lightweight state management library for vanilla JavaScript. It provides a simple API to manage local and global state with watchers, effects, and DOM binding, inspired by Reactâ€™s useState and useEffect.
 * Author: Ram Jam
 * GitHub: https://github.com/ramjam97/ram-state-js
 * Build Date: 2025-09-18 09:25:00 (Asia/Manila)
 */
function RamState(e={}){const n=new Set,t=function(){let e=new Set,n=!1;function t(){n=!0,e.forEach(e=>e()),e.clear(),n=!1}return function(a){e.add(a),n||Promise.resolve().then(t)}}();const a=(e,n)=>{if(e===n)return!0;if(typeof e!=typeof n)return!1;if(Array.isArray(e)&&Array.isArray(n))return e.length===n.length&&e.every((e,t)=>a(e,n[t]));if(e&&n&&"object"==typeof e){const t=Object.keys(e),c=Object.keys(n);return t.length===c.length&&t.every(t=>a(e[t],n[t]))}return!1},c=(e,n)=>{try{const t=n?e(n):e();return"function"==typeof t?t:null}catch(e){return console.error("RamState callback error:",e),null}},o=e=>{try{"function"==typeof e&&e()}catch(e){console.error("RamState cleanup error:",e)}};return(e.debug??1)&&console.log("%cRamState","color:cyan","v2.4.0","initialized ðŸš€"),{useState:function(e,t=null){let l=e;const s={onSet:[],onChange:[]},u=t?document.querySelector(t):null;u&&(d(u,l),u.addEventListener("input",()=>{const e=f(u);h.set(e)}),u.addEventListener("change",()=>{const e=f(u);h.set(e)}));const r=e=>({dom:u,value:l,hasChange:e}),i=()=>({dom:u,value:l});function f(e){return e instanceof HTMLInputElement?"checkbox"===e.type?e.checked:e.value:e instanceof HTMLSelectElement?e.multiple?[...e.selectedOptions].map(e=>e.value):e.value:e instanceof HTMLTextAreaElement?e.value:null}function d(e,n){if(e instanceof HTMLInputElement&&"checkbox"===e.type){const t=Boolean(n);return void(e.checked!==t&&(e.checked=t))}if(e instanceof HTMLSelectElement&&e.multiple&&Array.isArray(n)){const t=new Set(n.map(String));return void Array.from(e.options).forEach(e=>{const n=t.has(e.value);e.selected!==n&&(e.selected=n)})}const t=n??"";e.value!==t&&(e.value=t)}const h={dom:u,get value(){return l},set(e){"function"==typeof e&&(e=e(l));const n=!a(l,e);return l=e,u&&d(u,l),s.onSet.forEach(e=>{o(e.cleanup),e.cleanup=c(e.cb,r(n))}),n&&s.onChange.forEach(e=>{o(e.cleanup),e.cleanup=c(e.cb,i())}),l},watch(e){"function"==typeof e?s.onSet.push({cb:e,cleanup:c(e,r(!1))}):console.warn("watch callback must be a function")},watchEffect(e,n=!1){if("function"!=typeof e)return void console.warn("watchEffect callback must be a function");const t={cb:e,cleanup:null};n&&(t.cleanup=c(e,i())),s.onChange.push(t)}};return n.add(h),h},useEffect:function(e,a=null){if("function"!=typeof e)return void console.warn("useEffect callback must be a function");let l;function s(){o(l),l=c(e)}null==a?n.forEach(e=>e?.watchEffect(()=>t(s))):Array.isArray(a)&&a.forEach(e=>e?.watchEffect(()=>t(s))),s()},useMemo:function(e,n=[]){let a,l=[];const s=()=>({value:a});function u(){return a=e(),l.forEach(e=>{o(e.cleanup),e.cleanup=c(e.cb,s())}),a}return n.forEach(e=>e?.watchEffect(()=>t(u))),u(),{get value(){return a},watch(e){"function"==typeof e?l.push({cb:e,cleanup:c(e,s())}):console.warn("watchEffect callback must be a function")}}},useButton:function(e,t={}){const l={state:{disabled:t?.state?.disabled??!1,loading:t?.state?.loading??!1},disabled:{class:t?.disabled?.class??"disabled"},loading:{html:t?.loading?.html??"",icon:t?.loading?.icon??"",class:t?.loading?.class??"loading"}},s=[...e instanceof HTMLElement?[e]:"string"==typeof e?Array.from(document.querySelectorAll(e)):[]].map(e=>("function"==typeof l.loading.html&&(l.loading.html=l.loading.html(e.innerHTML)),{el:e,default:{html:e.innerHTML},loading:{html:l.loading.html||e.innerHTML,icon:l.loading.icon,class:l.loading.class},disabled:{class:l.disabled.class}})),u=s.map(e=>e.el);let r={disabled:l.state.disabled,loading:l.state.loading};const i={onSet:[],onChange:[]},f=e=>({dom:u,state:r,hasChange:e}),d=()=>({dom:u,state:r});function h(e){const n=!a(r,e);var t;return r=e,t=r,s.forEach(e=>{const{el:n}=e,a=e.default,c=e.loading,o=e.disabled;n.disabled=t.disabled||t.loading,n.classList.toggle(c.class,t.loading),n.classList.toggle(o.class,t.disabled),n.innerHTML=(t.loading?c.html:a.html)+(t.loading?c.icon:"")}),i.onSet.forEach(e=>{o(e.cleanup),e.cleanup=c(e.cb,f(n))}),n&&i.onChange.forEach(e=>{o(e.cleanup),e.cleanup=c(e.cb,d())}),r}const p={dom:u,get value(){return r},disabled:(e=!0)=>h({...r,disabled:e}),loading:(e=!0)=>h({...r,loading:e,disabled:e}),watch(e){"function"==typeof e?i.onSet.push({cb:e,cleanup:c(e,f(!1))}):console.warn("watch callback must be a function")},watchEffect(e,n=!1){if("function"!=typeof e)return void console.warn("watchEffect callback must be a function");const t={cb:e,cleanup:null};n&&(t.cleanup=c(e,d())),i.onChange.push(t)}};return n.add(p),p}}}