/*!
 * RamStateJs v2.1.0
 * Description: RamStateJs is a lightweight state management library for vanilla JavaScript. It provides a simple API to manage local and global state with watchers, effects, and DOM binding, inspired by Reactâ€™s useState and useEffect.
 * Author: Ram Jam
 * GitHub: https://github.com/ramjam97/ram-state-js
 */
function RamState(){const e=new Set,n=[],t=(e,n)=>{if(e===n)return!0;if(typeof e!=typeof n)return!1;if(Array.isArray(e)&&Array.isArray(n))return e.length===n.length&&e.every((e,c)=>t(e,n[c]));if(e&&n&&"object"==typeof e){const c=Object.keys(e),a=Object.keys(n);return c.length===a.length&&c.every(c=>t(e[c],n[c]))}return!1},c=(e,n)=>{try{const t=n?e(n):e();return"function"==typeof t?t:null}catch(e){return console.error("RamState callback error:",e),null}},a=e=>{try{e()}catch(e){console.error("RamState cleanup error:",e)}};return console.log("RamState v2.1.0 initialized ðŸš€"),{useState:function(o,u=null){let l=o;const r={always:[],onChange:[]},f=u?document.querySelector(u):null;f&&(h(f,l),f.addEventListener("input",()=>{p(y(f))}),f.addEventListener("change",()=>{p(y(f))}));const i=e=>({dom:f,data:l,hasChange:e}),s=()=>({dom:f,data:l});function p(e){"function"==typeof e&&(e=e(l));const o=!t(l,e);return l=e,f&&h(f,l),r.always.forEach(e=>{"function"==typeof e.cleanup&&a(e.cleanup),e.cleanup=c(e.cb,i(o))}),o&&r.onChange.forEach(e=>{"function"==typeof e.cleanup&&a(e.cleanup),e.cleanup=c(e.cb,s())}),n.forEach(({run:e,deps:n})=>{(null===n||o&&n.length>0&&n.includes(d))&&e()}),l}function y(e){return e instanceof HTMLInputElement?"checkbox"===e.type?e.checked:e.value:e instanceof HTMLSelectElement?e.multiple?[...e.selectedOptions].map(e=>e.value):e.value:e instanceof HTMLTextAreaElement?e.value:null}function h(e,n){e instanceof HTMLInputElement?"checkbox"===e.type?e.checked=!!n:e.value=n??"":e instanceof HTMLSelectElement?e.multiple&&Array.isArray(n)?[...e.options].forEach(e=>{e.selected=n.includes(e.value)}):e.value=n??"":e instanceof HTMLTextAreaElement&&(e.value=n??"")}const d={dom:f,get:()=>l,set:p,watch:function(e,n=!1){if("function"!=typeof e)return void console.warn("watch callback must be a function");const t={cb:e,cleanup:null};r.always.push(t),n&&(t.cleanup=c(e,i(!1)))},watchEffect:function(e,n=!1){if("function"!=typeof e)return void console.warn("watchEffect callback must be a function");const t={cb:e,cleanup:null};r.onChange.push(t),n&&(t.cleanup=c(e,s()))}};return e.add(d),d},useEffect:function(e,t=null){if("function"!=typeof e)return void console.warn("useEffect callback must be a function");let o;function u(){"function"==typeof o&&a(o),o=c(e)}const l={run:u,deps:t};n.push(l),u()}}}