/*!
 * RamStateJs v2.1.0
 * Description: RamStateJs is a lightweight state management library for vanilla JavaScript. It provides a simple API to manage local and global state with watchers, effects, and DOM binding, inspired by Reactâ€™s useState and useEffect.
 * Author: Ram Jam
 * GitHub: https://github.com/ramjam97/ram-state-js
 */
function RamState(e={}){const n=new Set,t=[],c=(e,n)=>{if(e===n)return!0;if(typeof e!=typeof n)return!1;if(Array.isArray(e)&&Array.isArray(n))return e.length===n.length&&e.every((e,t)=>c(e,n[t]));if(e&&n&&"object"==typeof e){const t=Object.keys(e),a=Object.keys(n);return t.length===a.length&&t.every(t=>c(e[t],n[t]))}return!1},a=(e,n)=>{try{const t=n?e(n):e();return"function"==typeof t?t:null}catch(e){return console.error("RamState callback error:",e),null}},o=e=>{try{e()}catch(e){console.error("RamState cleanup error:",e)}};return(e.debug??1)&&console.log("RamState v2.1.0 initialized ðŸš€"),{useState:function(e,u=null){let l=e;const r={always:[],onChange:[]},f=u?document.querySelector(u):null;f&&(h(f,l),f.addEventListener("input",()=>{p(y(f))}),f.addEventListener("change",()=>{p(y(f))}));const i=e=>({dom:f,data:l,hasChange:e}),s=()=>({dom:f,data:l});function p(e){"function"==typeof e&&(e=e(l));const n=!c(l,e);return l=e,f&&h(f,l),r.always.forEach(e=>{"function"==typeof e.cleanup&&o(e.cleanup),e.cleanup=a(e.cb,i(n))}),n&&r.onChange.forEach(e=>{"function"==typeof e.cleanup&&o(e.cleanup),e.cleanup=a(e.cb,s())}),t.forEach(({run:e,deps:t})=>{(null===t||n&&t.length>0&&t.includes(d))&&e()}),l}function y(e){return e instanceof HTMLInputElement?"checkbox"===e.type?e.checked:e.value:e instanceof HTMLSelectElement?e.multiple?[...e.selectedOptions].map(e=>e.value):e.value:e instanceof HTMLTextAreaElement?e.value:null}function h(e,n){e instanceof HTMLInputElement?"checkbox"===e.type?e.checked=!!n:e.value=n??"":e instanceof HTMLSelectElement?e.multiple&&Array.isArray(n)?[...e.options].forEach(e=>{e.selected=n.includes(e.value)}):e.value=n??"":e instanceof HTMLTextAreaElement&&(e.value=n??"")}const d={dom:f,get:()=>l,set:p,watch:function(e,n=!1){if("function"!=typeof e)return void console.warn("watch callback must be a function");const t={cb:e,cleanup:null};r.always.push(t),n&&(t.cleanup=a(e,i(!1)))},watchEffect:function(e,n=!1){if("function"!=typeof e)return void console.warn("watchEffect callback must be a function");const t={cb:e,cleanup:null};r.onChange.push(t),n&&(t.cleanup=a(e,s()))}};return n.add(d),d},useEffect:function(e,n=null){if("function"!=typeof e)return void console.warn("useEffect callback must be a function");let c;function u(){"function"==typeof c&&o(c),c=a(e)}const l={run:u,deps:n};t.push(l),u()}}}