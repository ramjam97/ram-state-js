/**
 * RamStateJs JavaScript Library v2.1.0
 * https://github.com/ramjam97/ram-state-js/blob/master/versions/2.1.0/ram-state.min.js
 *
 * RamState is a lightweight state management library designed specifically for vanilla JavaScript.
 * It provides a simple and efficient way to manage and update state without the need for additional frameworks.
 * It supports both direct and functional updates, offers easy state retrieval and allows side effects to be triggered on state changes.
 *
 * @returns {Object} An object with two methods: `useState` and `useEffect`.
 *                   `useState` is a function to create a new state instance with an initial value.
 *                   `useEffect` is a function to execute a side effect function when the state changes.
 */
function RamState(){const e=new Set,n=[];const t=e=>e instanceof HTMLInputElement?"checkbox"===e.type?e.checked:e.value:e instanceof HTMLSelectElement?e.multiple?[...e.selectedOptions].map((e=>e.value)):e.value:e instanceof HTMLTextAreaElement?e.value:null,c=(e,n)=>{e instanceof HTMLInputElement?"checkbox"===e.type?e.checked=!!n:e.value=n??"":e instanceof HTMLSelectElement?e.multiple&&Array.isArray(n)?[...e.options].forEach((e=>{e.selected=n.includes(e.value)})):e.value=n??"":e instanceof HTMLTextAreaElement&&(e.value=n??"")},a=(e,n)=>{if(e===n)return!0;if(typeof e!=typeof n)return!1;if(Array.isArray(e)&&Array.isArray(n))return e.length===n.length&&e.every(((e,t)=>a(e,n[t])));if(e&&n&&"object"==typeof e){const t=Object.keys(e),c=Object.keys(n);return t.length===c.length&&t.every((t=>a(e[t],n[t])))}return!1},l=(e,n)=>{try{const t=n?e(n):e();return t||null}catch(e){return console.error("RamState callback error:",e),null}},u=e=>{try{e()}catch(e){console.error("RamState cleanup error:",e)}};return console.log("RamState initialized ðŸš€"),{useState:function(o,r=null){let f=o;const s={always:[],onChange:[]},i=r?document.querySelector(r):null;function p(e){"function"==typeof e&&(e=e(f));const t=!a(f,e);return f=e,i&&c(i,f),s.always.forEach((e=>{"function"==typeof e.cleanup&&u(e.cleanup),e.cleanup=l(e.cb,{data:f,hasChange:t})})),t&&s.onChange.forEach((e=>{"function"==typeof e.cleanup&&u(e.cleanup),e.cleanup=l(e.cb,{data:f})})),n.forEach((({run:e,deps:n})=>{(null===n||t&&n.length>0&&n.includes(h))&&e()})),f}i&&(c(i,f),i.addEventListener("input",(()=>{p(t(i))})),i.addEventListener("change",(()=>{p(t(i))})));const h={get:function(){return f},set:p,watch:function(e,n=!1){if("function"!=typeof e)return void console.warn("watch callback must be a function");const t={cb:e,cleanup:null};s.always.push(t),n&&(t.cleanup=l(e,{data:f,hasChange:!1}))},watchEffect:function(e,n=!1){if("function"!=typeof e)return void console.warn("watchEffect callback must be a function");const t={cb:e,cleanup:null};s.onChange.push(t),n&&(t.cleanup=l(e,{data:f}))}};return e.add(h),h},useEffect:function(e,t=null){if("function"!=typeof e)return void console.warn("useEffect callback must be a function");let c;function a(){"function"==typeof c&&u(c),c=l(e)}const o={run:a,deps:t};n.push(o),a()}}}