/*!
 * RamStateJs JavaScript Library v1.4.0
 * https://github.com/ramjam97/ram-state-js
 * Date: 2024-08-05
 * 
 * A lightweight state management library with deep cloning, change detection,
 * and subscription-based updates. Handles complex data types (Set/Map/Date/RegExp)
 * and circular references.
*/ class RamState { #a; #b; #c; #d; #e; constructor(e) { if ("function" == typeof e) throw Error("Initial state cannot be a function."); this.#d = this.#f(e), this.#a = this.#f(e), this.#e = [], this.#b = [], this.#c = 0 } set(e) { let t = this.#a, i = "function" == typeof e ? e(this.#f(t)) : e, n = this.#f(i), s = !this.#g(t, n); s && (this.#c += 1, this.#a = n), this.#h(s, n, t, this.#c), s && this.#i(n, t, this.#c) } get() { return this.#f(this.#a) } get value() { return this.get() } get current() { return this.get() } get version() { return this.#c } uponSet(e, t = !1) { if ("function" == typeof e) { if (this.#e.push(e), t) try { e({ hasChange: !this.#g(this.#a, this.#d), current: this.#a, previous: this.#d, version: this.#c }) } catch (i) { console.error("Error in initial uponSet callback:", i) } } else console.warn("Callback provided to uponSet is not a function") } watch(e, t = !1) { return this.uponSet(e, t) } uponChange(e, t = !1) { if ("function" == typeof e) { if (this.#b.push(e), t) try { e({ current: this.#a, previous: this.#d, version: this.#c }) } catch (i) { console.error("Error in initial uponChange callback:", i) } } else console.warn("Callback provided to uponChange is not a function") } watchChange(e, t = !1) { return this.uponChange(e, t) } watchChanges(e, t = !1) { return this.uponChange(e, t) } reset(e = null) { let t = this.#a; e = null === e ? this.#f(this.#d) : this.#f(e); let i = !this.#g(t, e); i && (this.#c += 1), this.#a = e, this.#h(i, e, t, this.#c), i && this.#i(e, t, this.#c) } #h(e, t, i, n) { this.#e.forEach(s => { try { s({ hasChange: e, current: t, previous: i, version: n }) } catch (r) { console.error("Error in uponSet callback:", r) } }) } #i(s, r, o) { this.#b.forEach(e => { try { e({ current: s, previous: r, version: o }) } catch (t) { console.error("Error in uponChange callback:", t) } }) } #g(a, h) { if (a === h) return !0; if (a instanceof Set && h instanceof Set) return a.size === h.size && [...a].every(e => h.has(e)); if (a instanceof Map && h instanceof Map) { if (a.size !== h.size) return !1; for (let [f, u] of a) if (!h.has(f) || !this.#g(u, h.get(f))) return !1; return !0 } if (a instanceof Date && h instanceof Date) return a.getTime() === h.getTime(); if (a instanceof RegExp && h instanceof RegExp) return a.toString() === h.toString(); if ("object" != typeof a || "object" != typeof h || null === a || null === h) return !1; let c = Object.keys(a), l = Object.keys(h); return c.length === l.length && c.every(e => l.includes(e) && this.#g(a[e], h[e])) } #f(p, g = new WeakMap) { if ("object" != typeof p || null === p) return p; if (g.has(p)) return g.get(p); let C; if (p instanceof Date) C = new Date(p.getTime()); else if (p instanceof RegExp) C = RegExp(p.source, p.flags); else if (p instanceof Set) C = new Set([...p].map(e => this.#f(e, g))); else if (p instanceof Map) C = new Map([...p].map(([e, t]) => [this.#f(e, g), this.#f(t, g)])); else for (let v in C = Array.isArray(p) ? [] : Object.create(Object.getPrototypeOf(p)), g.set(p, C), p) p.hasOwnProperty(v) && (C[v] = this.#f(p[v], g)); return C } }