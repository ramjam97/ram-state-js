/*!
 * RamStateJs v2.2.0
 * Description: RamStateJs is a lightweight state management library for vanilla JavaScript. It provides a simple API to manage local and global state with watchers, effects, and DOM binding, inspired by Reactâ€™s useState and useEffect.
 * Author: Ram Jam
 * GitHub: https://github.com/ramjam97/ram-state-js
 */
function RamState(n={}){const e=new Set,t=[],a=(n,e)=>{if(n===e)return!0;if(typeof n!=typeof e)return!1;if(Array.isArray(n)&&Array.isArray(e))return n.length===e.length&&n.every((n,t)=>a(n,e[t]));if(n&&e&&"object"==typeof n){const t=Object.keys(n),l=Object.keys(e);return t.length===l.length&&t.every(t=>a(n[t],e[t]))}return!1},l=(n,e)=>{try{const t=e?n(e):n();return"function"==typeof t?t:null}catch(n){return console.error("RamState callback error:",n),null}},c=n=>{try{n()}catch(n){console.error("RamState cleanup error:",n)}};return(n.debug??1)&&console.log("RamState v2.2.0 initialized ðŸš€"),{useState:function(n,o=null){let u=n;const s={always:[],onChange:[]},i=o?document.querySelector(o):null;i&&(h(i,u),i.addEventListener("input",()=>{f(p(i))}),i.addEventListener("change",()=>{f(p(i))}));const r=n=>({dom:i,data:u,hasChange:n}),d=()=>({dom:i,data:u});function f(n){"function"==typeof n&&(n=n(u));const e=!a(u,n);return u=n,i&&h(i,u),s.always.forEach(n=>{"function"==typeof n.cleanup&&c(n.cleanup),n.cleanup=l(n.cb,r(e))}),e&&s.onChange.forEach(n=>{"function"==typeof n.cleanup&&c(n.cleanup),n.cleanup=l(n.cb,d())}),t.forEach(({run:n,deps:t})=>{(null===t||e&&t.length>0&&t.includes(g))&&n()}),u}function p(n){return n instanceof HTMLInputElement?"checkbox"===n.type?n.checked:n.value:n instanceof HTMLSelectElement?n.multiple?[...n.selectedOptions].map(n=>n.value):n.value:n instanceof HTMLTextAreaElement?n.value:null}function h(n,e){n instanceof HTMLInputElement?"checkbox"===n.type?n.checked=!!e:n.value=e??"":n instanceof HTMLSelectElement?n.multiple&&Array.isArray(e)?[...n.options].forEach(n=>{n.selected=e.includes(n.value)}):n.value=e??"":n instanceof HTMLTextAreaElement&&(n.value=e??"")}const g={dom:i,get:()=>u,set:f,watch:function(n,e=!1){if("function"!=typeof n)return void console.warn("watch callback must be a function");const t={cb:n,cleanup:null};s.always.push(t),e&&(t.cleanup=l(n,r(!1)))},watchEffect:function(n,e=!1){if("function"!=typeof n)return void console.warn("watchEffect callback must be a function");const t={cb:n,cleanup:null};s.onChange.push(t),e&&(t.cleanup=l(n,d()))}};return e.add(g),g},useEffect:function(n,e=null){if("function"!=typeof n)return void console.warn("useEffect callback must be a function");let a;function o(){"function"==typeof a&&c(a),a=l(n)}const u={run:o,deps:e};t.push(u),o()},useButton:function(n,o={}){const u={state:{disabled:o?.state?.disabled??!1,loading:o?.state?.loading??!1},disabled:{class:o?.disabled?.class??"disabled"},loading:{html:o?.loading?.html??"",icon:o?.loading?.icon??"",class:o?.loading?.class??"loading"}},s=[...n instanceof HTMLElement?[n]:"string"==typeof n?Array.from(document.querySelectorAll(n)):[]].map(n=>("function"==typeof u.loading.html&&(u.loading.html=u.loading.html(n.innerHTML)),{el:n,default:{html:n.innerHTML},loading:{html:u.loading.html||n.innerHTML,icon:u.loading.icon,class:u.loading.class},disabled:{class:u.disabled.class}})),i=s.map(n=>n.el);let r={disabled:u.state.disabled,loading:u.state.loading};const d={always:[],onChange:[]},f=n=>({dom:i,state:r,hasChange:n}),p=()=>({dom:i,state:r}),h=n=>{s.forEach(e=>{const{el:t}=e,a=e.default,l=e.loading,c=e.disabled;t.disabled=n.disabled||n.loading,t.classList.toggle(l.class,n.loading),t.classList.toggle(c.class,n.disabled),t.innerHTML=(n.loading?l.html:a.html)+(n.loading?l.icon:"")})};function g(n){const e=!a(r,n);return r=n,h(r),d.always.forEach(n=>{"function"==typeof n.cleanup&&c(n.cleanup),n.cleanup=l(n.cb,f(e))}),e&&d.onChange.forEach(n=>{"function"==typeof n.cleanup&&c(n.cleanup),n.cleanup=l(n.cb,p())}),t.forEach(({run:n,deps:t})=>{(null===t||e&&t.length>0&&t.includes(b))&&n()}),r}const b={dom:i,get:()=>r,disabled:(n=!0)=>g({...r,disabled:n}),loading:(n=!0)=>g({...r,loading:n,disabled:n}),watch:function(n,e=!1){if("function"!=typeof n)return void console.warn("watch callback must be a function");const t={cb:n,cleanup:null};d.always.push(t),e&&(t.cleanup=l(n,f(!1)))},watchEffect:function(n,e=!1){if("function"!=typeof n)return void console.warn("watchEffect callback must be a function");const t={cb:n,cleanup:null};d.onChange.push(t),e&&(t.cleanup=l(n,p()))}};return e.add(b),b}}}