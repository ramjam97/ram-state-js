/*!
 * RamStateJs v2.2.0
 * Description: RamStateJs is a lightweight state management library for vanilla JavaScript. It provides a simple API to manage local and global state with watchers, effects, and DOM binding, inspired by Reactâ€™s useState and useEffect.
 * Author: Ram Jam
 * GitHub: https://github.com/ramjam97/ram-state-js
 */
function RamState(n={}){const e=new Set,t=[],c=(n,e)=>{if(n===e)return!0;if(typeof n!=typeof e)return!1;if(Array.isArray(n)&&Array.isArray(e))return n.length===e.length&&n.every((n,t)=>c(n,e[t]));if(n&&e&&"object"==typeof n){const t=Object.keys(n),a=Object.keys(e);return t.length===a.length&&t.every(t=>c(n[t],e[t]))}return!1},a=(n,e)=>{try{const t=e?n(e):n();return"function"==typeof t?t:null}catch(n){return console.error("RamState callback error:",n),null}},o=n=>{try{n()}catch(n){console.error("RamState cleanup error:",n)}};return(n.debug??1)&&console.log("RamState v2.2.0 initialized ðŸš€"),{useState:function(n,l=null){let u=n;const r={always:[],onChange:[]},s=l?document.querySelector(l):null;s&&(h(s,u),s.addEventListener("input",()=>{d(p(s))}),s.addEventListener("change",()=>{d(p(s))}));const i=n=>({dom:s,data:u,hasChange:n}),f=()=>({dom:s,data:u});function d(n){"function"==typeof n&&(n=n(u));const e=!c(u,n);return u=n,s&&h(s,u),r.always.forEach(n=>{"function"==typeof n.cleanup&&o(n.cleanup),n.cleanup=a(n.cb,i(e))}),e&&r.onChange.forEach(n=>{"function"==typeof n.cleanup&&o(n.cleanup),n.cleanup=a(n.cb,f())}),t.forEach(({run:n,deps:t})=>{(null===t||e&&t.length>0&&t.includes(y))&&n()}),u}function p(n){return n instanceof HTMLInputElement?"checkbox"===n.type?n.checked:n.value:n instanceof HTMLSelectElement?n.multiple?[...n.selectedOptions].map(n=>n.value):n.value:n instanceof HTMLTextAreaElement?n.value:null}function h(n,e){n instanceof HTMLInputElement?"checkbox"===n.type?n.checked=!!e:n.value=e??"":n instanceof HTMLSelectElement?n.multiple&&Array.isArray(e)?[...n.options].forEach(n=>{n.selected=e.includes(n.value)}):n.value=e??"":n instanceof HTMLTextAreaElement&&(n.value=e??"")}const y={dom:s,get:()=>u,set:d,watch:function(n,e=!1){if("function"!=typeof n)return void console.warn("watch callback must be a function");const t={cb:n,cleanup:null};r.always.push(t),e&&(t.cleanup=a(n,i(!1)))},watchEffect:function(n,e=!1){if("function"!=typeof n)return void console.warn("watchEffect callback must be a function");const t={cb:n,cleanup:null};r.onChange.push(t),e&&(t.cleanup=a(n,f()))}};return e.add(y),y},useEffect:function(n,e=null){if("function"!=typeof n)return void console.warn("useEffect callback must be a function");let c;function l(){"function"==typeof c&&o(c),c=a(n)}const u={run:l,deps:e};t.push(u),l()},useButton:function(n){const e=n instanceof HTMLElement?n:"string"==typeof n?Array.from(document.querySelectorAll(n)):null;let l={disabled:!1,loading:!1};const u={always:[],onChange:[]},r=n=>({dom:e,state:l,hasChange:n}),s=()=>({dom:e,state:l}),i=n=>{function t(e){console.log("elem",e),e instanceof HTMLElement&&(e.disabled=n?.disabled||n?.loading,e.classList.toggle("loading",n?.loading),e.classList.toggle("disabled",n?.disabled))}e&&(e instanceof Array?e.forEach(n=>t(n)):t(e))};function f(n){const e=!c(l,n);return l=n,i(l),u.always.forEach(n=>{"function"==typeof n.cleanup&&o(n.cleanup),n.cleanup=a(n.cb,r(e))}),e&&u.onChange.forEach(n=>{"function"==typeof n.cleanup&&o(n.cleanup),n.cleanup=a(n.cb,s())}),t.forEach(({run:n,deps:t})=>{(null===t||e&&t.length>0&&t.includes(stateAPI))&&n()}),l}return{dom:e,get:()=>l,disabled:(n=!0)=>f({...l,disabled:n}),loading:(n=!0)=>f({...l,loading:n,disabled:n}),watch:function(n,e=!1){if("function"!=typeof n)return void console.warn("watch callback must be a function");const t={cb:n,cleanup:null};u.always.push(t),e&&(t.cleanup=a(n,r(!1)))},watchEffect:function(n,e=!1){if("function"!=typeof n)return void console.warn("watchEffect callback must be a function");const t={cb:n,cleanup:null};u.onChange.push(t),e&&(t.cleanup=a(n,s()))}}}}}